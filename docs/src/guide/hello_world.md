# Hello world

As the first step, we will build a simple application, starting with a classic Hello World, adding some state, and finally a remote API call. We will focus on the core, and return to the shell a little later, so unfortunately there won't be much to see until then.

If you want to follow along, you should start by following the [Shared core and types](../getting_started/core.md), guide to set up the project.

## Side-effects and capabilities

I know we said we'd build a simple application, but we need to start by talking about side-effects a little. One of the key design choices in Crux is that the Core is free of side-effects (besides its internal state). Your application can never _perform_ anything that directly interacts with the environment around it - no network calls, no reading/writing files, and (somewhat obviously) not even updating the screen. Actually _doing_ all those things is the job of the Shell, the core can only _ask_ for them to be done.

This makes the core portable between platforms, and, importantly, really easy to test. It also separates the intent, the "functional" requirements, from the implementation of the side-effects and the "non-functional" requirements (NFRs). For example, your application knows it wants to store data in a SQL database, but it doesn't need to know or care whether that database is local or remote. That decision can even change as the application evolves. You can read a lot more about how side-effects work in Crux in the chapter on [capabilities](./capabilities.md).

To _ask_ the Shell for side effects, we will need to describe the possible side-effects the Core will request. And to help us create these requests (generated by the `Effect` derive macro), we can use capabilities - reusable bits of functionality which give us a nice API for performing side-effects. We'll look at them in a lot more detail later.

```rust
use crux_core::render::Render;

pub struct Capabilities {
    render: Render<Event>,
}
```

For now, we will need a single capability, `Render`, which is built into Crux and available from the `crux_core` crate. It simply tells the shell to update the screen using the latest information.

That means the core also produces a single `Effect`, but it will soon be more than one, so it is wrapped in an enum. Rather than generate this enum ourselves (and associated trait implementations), we can use the `Effect` derive macro from the `crux_macros` crate.

The resulting code for the capabilities will end up looking like this (but bear in mind that the `Effect` derive macro will be expecting a struct that implements the `App` trait, and an `Event` enum — which we talk about in the next section).

```rust
use crux_core::{render::Render, App};
use crux_macros::Effect;
use serde::{Deserialize, Serialize};

#[derive(Effect)]
#[effect(app = "Hello")]
pub struct Capabilities {
    render: Render<Event>,
}

#[derive(Serialize, Deserialize)]
pub enum Event;

#[derive(Default)]
pub struct Hello;

impl App for Hello { ... }
```

With this short detour out of the way, we can finally create an app and start implementing some behavior.

## Creating an app

To start with, we need a `struct` to be the root of our app.

```rust
#[derive(Default)]
pub struct Hello;
```

We need to implement `Default` so that Crux can construct the app for us.

To turn it into an app, we need to implement the `App` trait from the `crux_core` crate. And we'll need a few dependencies to make it work as well.

```rust
use crux_core::{render::Render, App};
use crux_macros::Effect;
use serde::{Deserialize, Serialize};

#[derive(Default)]
pub struct Model;

#[derive(Serialize, Deserialize)]
pub enum Event;

impl App for Hello {
    type Event = Event;
    type Model = Model;
    type ViewModel = String;
    type Capabilities = Capabilities;

    fn update(&self, _event: Self::Event, _model: &mut Self::Model, caps: &Self::Capabilities) {
        caps.render.render();
    }

    fn view(&self, _model: &Self::Model) -> Self::ViewModel {
        "Hello World!".to_string()
    }
}
```

There's a fair bit going on, so lets look at all of it one by one:

The trait has four associated types. The `Event` type describes the possible actions this app can perform. For now its's an empty enum. The `Model` describes the internal state of the app, also a zero-sized type for now, as there is no state to hold. The `ViewModel` describes the user interface to display. The `Capabilities` type lets us control what capabilities the core has access to.

The `update` function is the heart of the app. It responds to events by (optionally) updating the state and requesting some effects by using the relevant method on the relevant capability.

All our `update` function does is ignore all its arguments and ask the Shell to render the screen.

Finally, the `view` function returns the representation of what we want the Shell to show on screen. To start with, it's a simple hello world.

That's a working hello world done, lets try it. For now we'll do it from tests. That's not really a limitation, in fact, this is the intended way for apps to be developed with Crux - from inside out, with unit tests, focusing on behavior first and presentation later.

```rust
#[cfg(test)]
mod tests {
    use crux_core::{Core, Command};
    use super::*;

    #[test]
    fn hello_says_hello_world() {
        let hello = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        // Call 'update' and request effects
        let update = hello.update((), &mut model);

        // Check update asked us to `Render`
        assert_eq!(update.effects[0], Effect::Render(RenderOperation));

        let actual_view = hello.view(&mut model);
        let expected_view = "Hello World".to_string();

        assert_eq!(actual_view, expected_view);
    }
}
```

It is a fairly underwhelming test, but it should pass (check with `cargo test`).

## Counting up and down

To make things more interesting, we'll add some behaviour. We'll teach the app to count up and down. First, we'll need a model, which represents the state. We could just use a number, but we'll use a struct instead, so that we can easily add more state later.

```rust
#[derive(Default)]
struct Model {
    count: isize,
}
```

We need `Default` implemented to define the initial state. For now we derive it, as our state is quite simple. We also update the app to use the model:

```rust
impl App for Hello {
// ...

    type Model = Model;

// ...

    fn view(&self, model: &Self::Model) -> Self::ViewModel {
        format!("Count is: {}", model.count)
    }
}
```

Great. All that's left is adding the behaviour. That's where `Event` comes in:

```rust
#[derive(Serialize, Deserialize)]
enum Event {
    Increment,
    Decrement,
    Reset,
}
```

The event type covers all the possible events we can respond to. "Will that not get massive really quickly??" I hear you ask. Don't worry about that, there is [a way to make this scale](./composing.md). Let's carry on. We need to actually handle those messages.

```rust

impl App for Hello {
    type Model = Model;
    type Event = Event;
    type ViewModel = String;
    type Capabilities = Capabilities;

    fn update(&self, event: Self::Event, model: &mut Self::Model, caps: &Self::Capabilities) {
        match event {
            Event::Increment => model.count += 1,
            Event::Decrement => model.count -= 1,
            Event::Reset => model.count = 0,
        };

        caps.render.render();
    }

// ...
```

Pretty straightforward, we just do what we're told, update the state, and then tell the Shell to render. Lets update the tests to check everything works as expected.

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crux_core::{render::RenderOperation, testing::AppTester};

    #[test]
    fn renders() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        let update = app.update(Event::Reset, &mut model);

        assert_eq!(update.effects[0], Effect::Render(RenderOperation));
    }

    #[test]
    fn shows_initial_count() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        let actual_view = app.view(&mut model);
        let expected_view = "Count is: 0";

        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn increments_count() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        app.update(Event::Increment, &mut model);

        let actual_view = app.view(&mut model);
        let expected_view = "Count is: 1";

        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn decrements_count() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        app.update(Event::Decrement, &mut model);

        let actual_view = app.view(&mut model);
        let expected_view = "Count is: -1";

        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn resets_count() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        app.update(Event::Increment, &mut model);
        app.update(Event::Reset, &mut model);

        let actual_view = app.view(&mut model);
        let expected_view = "Count is: 0";

        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn counts_up_and_down() {
        let app = AppTester::<Hello, _>::default();
        let mut model = Model::default();

        app.update(Event::Increment, &mut model);
        app.update(Event::Reset, &mut model);
        app.update(Event::Decrement, &mut model);
        app.update(Event::Increment, &mut model);
        app.update(Event::Increment, &mut model);

        let actual_view = app.view(&mut model);
        let expected_view = "Count is: 1";

        assert_eq!(actual_view, expected_view);
    }
}
```

Hopefully those all pass. We are now sure that when we build an actual UI for this, it will _work_, and we'll be able to focus on making it looking delightful.

## Remote API

Before we dive into the thinking behind the architecture, let's add one more feature - a remote API call - to get a better feel for how side-effects work.

**TO DO**
